<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrueNAS Installer</title>
    <style>
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body Styles */
        body {
            min-height: 100vh;
            background-color: #171717;
            color: #f9fafb;
            font-family: system-ui, -apple-system, sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Loader Components */
        .loader-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #171717;
            z-index: 50;
        }

        .loader-content {
            text-align: center;
        }

        .spinner {
            display: inline-block;
            width: 48px;
            height: 48px;
            border: 2px solid transparent;
            border-bottom: 2px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Icon Styles */
        .icon-large {
            font-size: 48px !important;
            font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 48;
            line-height: 1;
            display: inline-block;
        }

        /* Text Utilities */
        .text-success { color: #10b981; }
        .text-error { color: #ef4444; }

        .status-message {
            margin-top: 1rem;
            color: #d1d5db;
            font-weight: 500;
            font-size: 1.5rem;
        }
    </style>
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=swap" />
</head>

<body>
    <main id="app" role="main" aria-live="polite"></main>

    <script>
        // UI State Management
        class UIState {
            constructor() {
                this.showLoader = true;
                this.loaderState = 'loading';
                this.statusMessage = 'Connecting...';
            }

            updateUI() {
                const app = document.getElementById('app');
                
                if (!this.showLoader) {
                    app.innerHTML = '';
                    return;
                }

                const iconHTML = this.getIconHTML();
                app.innerHTML = `
                    <div class="loader-overlay">
                        <div class="loader-content">
                            ${iconHTML}
                            <p class="status-message">${this.statusMessage}</p>
                        </div>
                    </div>
                `;
            }

            getIconHTML() {
                const iconMap = {
                    loading: '<div class="spinner"></div>',
                    success: '<div><span class="material-symbols-outlined icon-large text-success">check_circle</span></div>',
                    error: '<div><span class="material-symbols-outlined icon-large text-error">cancel</span></div>'
                };
                return iconMap[this.loaderState] || '';
            }

            setShowLoader(value) {
                this.showLoader = value;
                this.updateUI();
            }

            setLoaderState(value) {
                this.loaderState = value;
                this.updateUI();
            }

            setStatusMessage(value) {
                this.statusMessage = value;
                this.updateUI();
            }

            setStatus(message, state = null) {
                this.statusMessage = message;
                if (state) this.loaderState = state;
                this.updateUI();
            }
        }

        // Global UI instance
        const uiState = new UIState();
        
        // Legacy function wrappers for compatibility
        const setShowLoader = (value) => uiState.setShowLoader(value);
        const setLoaderState = (value) => uiState.setLoaderState(value);
        const setStatusMessage = (value) => uiState.setStatusMessage(value);

        class RPCClient {
            constructor(url, config) {
                this.ws = new WebSocket(url);
                this.config = config;
                this.pendingRequests = new Map();
                this.pingInterval = null;
                this.retryStartTime = null;
                this.maxRetryDuration = 10 * 60 * 1000;
                this.retryInterval = 5000;
                this.retryTimeout = null;
                this.connect();
            }


            connect() {
                this.ws = new WebSocket(this.url);
                this.setupEventHandlers();
            }

            setupEventHandlers() {
                this.ws.onopen = () => {
                    uiState.setStatus('Websocket is connected');
                    this.retryStartTime = null;
                    this.startPing();
                    this.onConnected();
                };

                this.ws.onmessage = (event) => {
                    try {
                        const response = JSON.parse(event.data);
                        this.handleResponse(response);
                    } catch (error) {
                        uiState.setStatus('Failed to parse response', 'error');
                    }
                };

                this.ws.onclose = () => {
                    this.stopPing();
                    this.handleConnectionLoss();
                };

                this.ws.onerror = () => {
                    uiState.setStatus('WebSocket connection failed', 'error');
                };
            }

            handleConnectionLoss() {
                if (this.retryStartTime === null) {
                    this.retryStartTime = Date.now();
                }
                
                const elapsedTime = Date.now() - this.retryStartTime;
                if (elapsedTime < this.maxRetryDuration) {
                    this.scheduleRetry();
                } else {
                    uiState.setStatus('Websocket connection failed', 'error');
                    uiState.setShowLoader(true);
                }
            }

            call(method, params = []) {
                return new Promise((resolve, reject) => {
                    const id = this.generateUUID();
                    const request = {
                        id,
                        jsonrpc: '2.0',
                        method,
                        params
                    };

                    this.pendingRequests.set(id, { resolve, reject });
                    this.ws.send(JSON.stringify(request));
                });
            }

            handleResponse(response) {
                if (response.id && this.pendingRequests.has(response.id)) {
                    const { resolve, reject } = this.pendingRequests.get(response.id);
                    this.pendingRequests.delete(response.id);
                    if (response.error) {
                        reject(response.error);
                    } else {
                        resolve(response.result);
                    }
                } else if (response.method) {
                    this.handleEvent(response);
                }
            }

            handleEvent(event) {
                switch (event.method) {
                    case 'installation_progress':
                        this.onInstallationProgress(event.params[0]);
                        break;
                    default:
                        console.error('Unhandled event:', event);
                }
            }

            onInstallationProgress(data) {
                const { progress, message } = data;
                const percentage = Math.round(progress * 100);
                uiState.setStatus(`${message} (${percentage}%)`, 'loading');
                uiState.setShowLoader(true);
            }

            startPing() {
                this.pingInterval = setInterval(() => {
                    this.ping();
                }, 30000);
            }

            stopPing() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }

            scheduleRetry() {
                uiState.setStatus('Connection lost. Retrying...', 'loading');
                uiState.setShowLoader(true);
                
                this.retryTimeout = setTimeout(() => {
                    this.connect();
                }, this.retryInterval);
            }

            cleanup() {
                this.stopPing();
                if (this.retryTimeout) {
                    clearTimeout(this.retryTimeout);
                    this.retryTimeout = null;
                }
            }

            async ping() {
                try {
                    await this.call('system_info');
                } catch (error) {
                    console.error('Ping failed:', error);
                }
            }

            async onConnected() {
                try {
                    const accessKey = await this.handleAuthentication();
                    const systemInfo = await this.call('system_info');
                    
                    if (await this.handleSystemStatus(systemInfo)) {
                        return;
                    }

                    await this.handleTNCSetup(accessKey);
                } catch (error) {
                    console.error(error);
                    uiState.setStatus(
                        error?.message || 'Setup failed', 
                        'error'
                    );
                }
            }

            async handleAuthentication() {
                uiState.setStatus('Getting things ready...');
                const isAdopted = await this.call('is_adopted');
                
                let accessKey;
                if (!isAdopted) {
                    accessKey = await this.call('adopt');
                    localStorage.setItem('accessKey', accessKey);
                } else {
                    accessKey = localStorage.getItem('accessKey');
                }

                if (!accessKey) {
                    throw new Error('No Access Key');
                }

                await this.call('authenticate', accessKey);
                return accessKey;
            }

            async handleSystemStatus(systemInfo) {
                if (systemInfo.installation_completed) {
                    uiState.setStatus('Installation complete', 'success');
                    return true;
                }
                if (systemInfo.installation_running) {
                    uiState.setStatus('Installation in progress');
                    return true;
                }
                return false;
            }

            async handleTNCSetup(accessKey) {
                const tncConfig = await this.call('tnc_config');
                
                if (tncConfig.initialization_error) {
                    throw new Error(tncConfig.initialization_error);
                }
                
                if (Object.keys(tncConfig.registration_details).length) {
                    uiState.setStatus('Please continue the setup in TrueNAS Connect UI');
                    return;
                }

                this.validateConfig();
                
                if (!tncConfig.enabled) {
                    await this.call('configure_tnc', [{ ...this.config, enabled: true }]);
                }

                uiState.setStatus('Generating TrueNAS Connect registration URL');
                const urlResult = await this.call('tnc_registration_uri');
                uiState.setStatus('The TrueNAS Connect registration URL is ready');
                
                window.location.replace(`${urlResult}&installer_token=${accessKey}`);
            }

            validateConfig() {
                const requiredFields = [
                    'account_service_base_url',
                    'leca_service_base_url', 
                    'heartbeat_service_base_url',
                    'tnc_base_url'
                ];
                
                const hasAllFields = this.config && 
                    requiredFields.every(field => this.config[field]);
                    
                if (!hasAllFields) {
                    throw new Error('Missing required configuration');
                }
            }

            generateUUID() {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return crypto.randomUUID();
                }

                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
        }

        // Application Initialization
        class App {
            constructor() {
                this.init();
            }

            init() {
                uiState.updateUI();
                this.initializeRPCClient();
            }

            initializeRPCClient() {
                try {
                    const config = this.parseUrlConfig();
                    new RPCClient('ws://truenas-installer.local:8080/ws', config);
                } catch (error) {
                    console.error(error);
                    uiState.setStatus('Invalid URL', 'error');
                }
            }

            parseUrlConfig() {
                const urlParams = new URLSearchParams(window.location.search);
                const configParam = urlParams.get('config');
                
                if (!configParam) {
                    throw new Error('No configuration provided');
                }

                return JSON.parse(decodeURIComponent(configParam));
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new App();
        });
    </script>
</body>

</html>